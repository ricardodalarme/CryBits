using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;
using System.Runtime.CompilerServices;
using Avalonia.Controls;
using Avalonia.Controls.Primitives;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.Media.Imaging;
using Avalonia.Threading;
using CryBits.Client.Framework;
using CryBits.Client.Framework.Audio;
using CryBits.Client.Framework.Entities.Tile;
using CryBits.Client.Framework.Graphics;
using CryBits.Editors.AvaloniaUI;
using CryBits.Editors.Entities;
using CryBits.Editors.Graphics;
using CryBits.Editors.Logic;
using CryBits.Editors.Network;
using CryBits.Entities;
using CryBits.Entities.Map;
using CryBits.Entities.Npc;
using CryBits.Enums;
using CryBits.Extensions;
using SFML.Graphics;
using static CryBits.Editors.Logic.Utils;
// Note: Globals.Grid (byte) and Avalonia.Controls.Grid (type) differ in kind
using AvaloniaScrollEventArgs = Avalonia.Controls.Primitives.ScrollEventArgs;
using SelectionChangedEventArgs = Avalonia.Controls.SelectionChangedEventArgs;
using TextChangedEventArgs = Avalonia.Controls.TextChangedEventArgs;
using AvaloniaNumericUpDownValueChangedEventArgs = Avalonia.Controls.NumericUpDownValueChangedEventArgs;
using AvaloniaColor = Avalonia.Media.Color;
using SystemColor = System.Drawing.Color;
using SystemPoint = System.Drawing.Point;
using SystemSize = System.Drawing.Size;
using SystemRect = System.Drawing.Rectangle;

namespace CryBits.Editors.AvaloniaUI.Forms;

// Cross-platform replacement for System.Windows.Forms.MouseButtons
internal enum MouseButtons { None, Left, Right }

// ──────────────────────────────────────────────────────────────────────────────
// Layer view-model for the DataGrid
// ──────────────────────────────────────────────────────────────────────────────
internal sealed class LayerVm : INotifyPropertyChanged
{
    private bool _visible = true;
    public int Index { get; init; }
    public string Name { get; init; } = string.Empty;
    public string TypeName { get; init; } = string.Empty;

    public bool Visible
    {
        get => _visible;
        set { _visible = value; OnPropertyChanged(); }
    }

    public event PropertyChangedEventHandler? PropertyChanged;
    private void OnPropertyChanged([CallerMemberName] string? n = null)
        => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(n));
}

internal partial class EditorMapsWindow : Window
{
    // ── Public static accessors consumed by Renders.cs ────────────────────────
    public static EditorMapsWindow? Instance { get; private set; }

    // Tool states (read by Renders)
    public bool ModeNormal => butMNormal.IsChecked == true;
    public bool ModeZones => butMZones.IsChecked == true;
    public bool ModeAttributes => butMAttributes.IsChecked == true;
    public bool ModeNPCs => butMNPCs.IsChecked == true;

    public bool ToolPencil => butPencil.IsChecked == true;
    public bool ToolRectangle => butRectangle.IsChecked == true;
    public bool ToolArea => butArea.IsChecked == true;
    public bool ToolDiscover => butDiscover.IsChecked == true;

    public bool ShowGrid => butGrid.IsChecked == true;
    public bool ShowEdition => butEdition.IsChecked == true;
    public bool ShowVisualization => butVisualization.IsChecked == true;
    public bool ShowAudio => butAudio.IsChecked == true;
    public bool DirBlockMode => optA_DirBlock.IsChecked == true;

    public bool AutoTile => chkAuto.IsChecked == true;

    public int TileSheetIndex => cmbTiles.SelectedIndex;
    public int TileScrollX => (int)scrlTileX.Value;
    public int TileScrollY => (int)scrlTileY.Value;
    public int MapScrollX => (int)scrlMapX.Value;
    public int MapScrollY => (int)scrlMapY.Value;

    public SystemPoint TileMouse { get; private set; }

    // Map canvas size (used by Renders to size WinMapRT)
    public int MapCanvasWidth { get; private set; } = 800;
    public int MapCanvasHeight { get; private set; } = 600;

    // Tile canvas size
    public int TileCanvasWidth { get; private set; } = 282;
    public int TileCanvasHeight { get; private set; } = 420;

    // Convenience accessor for Renders.cs
    public Map? SelectedMap => _selected;

    // ── Private state ────────────────────────────────────────────────────────
    private Map? _selected;
    private bool _loading;
    private bool _mapPressed;
    private bool _layerEditIsNew;

    // lstLayers is auto-generated by Avalonia source generator from AXAML x:Name

    private SystemPoint _mapMouse;
    private SystemRect _defTilesSelection = new(0, 0, 1, 1);
    private SystemRect _defMapSelection = new(0, 0, 1, 1);

    private string _aData1 = string.Empty;
    private short _aData2;
    private short _aData3;
    private short _aData4;

    private CopyStruct _tilesCopy;

    private struct CopyStruct
    {
        public SystemRect Area;
        public MapLayer[]? Data;
    }

    // Render bitmaps
    private WriteableBitmap? _mapBitmap;
    private WriteableBitmap? _tileBitmap;

    // Timer
    private DispatcherTimer? _timer;

    // Layer view-models
    private List<LayerVm> _layerVms = new();

    // ── Constructor ──────────────────────────────────────────────────────────
    public EditorMapsWindow()
    {
        InitializeComponent();
        Instance = this;

        // Layer type combo
        foreach (Layer l in Enum.GetValues<Layer>())
            cmbLayers_Type.Items.Add(l.ToString());

        // Tile sheet combo
        for (var i = 1; i < Textures.Tiles.Count; i++)
            cmbTiles.Items.Add(i.ToString());
        if (cmbTiles.Items.Count > 0) cmbTiles.SelectedIndex = 0;

        // Enums
        foreach (Moral m in Enum.GetValues<Moral>())
            cmbMoral.Items.Add(m.ToString());
        foreach (Weather w in Enum.GetValues<Weather>())
            cmbWeather.Items.Add(w.ToString());

        // Zone scroll limit
        scrlZone.Maximum = Globals.MaxZones;
        numNPC_Zone.Maximum = Globals.MaxZones;

        // SFML offscreen render textures
        Renders.WinMapRT = new RenderTexture((uint)MapCanvasWidth, (uint)MapCanvasHeight);
        Renders.WinMapTileRT = new RenderTexture((uint)TileCanvasWidth, (uint)TileCanvasHeight);

        // 30 fps timer
        _timer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(33) };
        _timer.Tick += OnRenderTick;
        _timer.Start();

        RefreshMapList();
    }

    protected override void OnClosed(EventArgs e)
    {
        _timer?.Stop();
        Renders.WinMapRT = null;
        Renders.WinMapTileRT = null;
        Instance = null;
        base.OnClosed(e);
    }

    // ─────────────────────────────────────────────────────────────────────────
    // RENDER TICK
    // ─────────────────────────────────────────────────────────────────────────

    private void OnRenderTick(object? sender, EventArgs e)
    {
        // Map canvas
        if (Renders.WinMapRT != null && _selected != null)
        {
            Renders.EditorMapsMapRT();
            SfmlRenderBlit.Blit(Renders.WinMapRT, ref _mapBitmap, imgMap);
        }

        // Tile canvas (only in Normal mode)
        if (Renders.WinMapTileRT != null && ModeNormal)
        {
            Renders.EditorMapsTileRT();
            SfmlRenderBlit.Blit(Renders.WinMapTileRT, ref _tileBitmap, imgTile);
        }

        UpdateStatusBar();
    }

    // ─────────────────────────────────────────────────────────────────────────
    // MAP LIST
    // ─────────────────────────────────────────────────────────────────────────

    private void RefreshMapList(Guid? keepId = null)
    {
        var filter = txtFilter.Text ?? string.Empty;
        var filtered = Map.List.Values
            .Where(m => m.Name.StartsWith(filter, StringComparison.OrdinalIgnoreCase))
            .ToList();

        lstMaps.ItemsSource = filtered;

        if (keepId.HasValue)
            lstMaps.SelectedItem = filtered.FirstOrDefault(m => m.Id == keepId.Value);

        if (lstMaps.SelectedItem == null && filtered.Count > 0)
            lstMaps.SelectedIndex = 0;
    }

    private void lstMaps_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        if (lstMaps.SelectedItem is not Map map) return;
        SelectMap(map);
    }

    private void SelectMap(Map map)
    {
        _selected = map;
        _loading = true;

        // Warp map combo
        RefreshWarpMapCombo();

        // Map properties
        txtMapName.Text = map.Name;
        cmbMoral.SelectedIndex = (int)map.Moral;
        txtMapMusic.Text = map.Music;

        numFogTexture.Value = map.Fog.Texture;
        numFogAlpha.Value = map.Fog.Alpha;
        numFogSpeedX.Value = map.Fog.SpeedX;
        numFogSpeedY.Value = map.Fog.SpeedY;

        cmbWeather.SelectedIndex = (int)map.Weather.Type;
        numWeatherIntensity.Value = map.Weather.Intensity;

        numHueR.Value = map.Color.R;
        numHueG.Value = map.Color.G;
        numHueB.Value = map.Color.B;

        numLighting.Value = map.Lighting;
        numPanorama.Value = map.Panorama;

        // NPCs
        RefreshNpcList();

        // Weather
        TempMap.UpdateWeatherType();

        // Auto-tile maths
        map.Update();

        // Update canvas bounds
        UpdateMapBounds();

        // Layers
        RefreshLayerList();

        _loading = false;
    }

    private void RefreshWarpMapCombo()
    {
        cmbA_Warp_Map.Items.Clear();
        foreach (var m in Map.List.Values) cmbA_Warp_Map.Items.Add(m);
        if (cmbA_Warp_Map.Items.Count > 0) cmbA_Warp_Map.SelectedIndex = 0;
        numA_Warp_X.Maximum = Map.Width - 1;
        numA_Warp_Y.Maximum = Map.Height - 1;
    }

    private void txtFilter_TextChanged(object? sender, TextChangedEventArgs e)
    {
        RefreshMapList(_selected?.Id);
    }

    private void butNew_Click(object? sender, RoutedEventArgs e)
    {
        var map = new Map();
        Map.List.Add(map.Id, map);
        RefreshMapList(map.Id);
    }

    private void butRemove_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null) return;
        if (Map.List.Count == 1)
        {
            MessageBox.Show(@"It must have at least one map registered.");
            return;
        }
        Map.List.Remove(_selected.Id);
        _selected = null;
        RefreshMapList();
    }

    // ─────────────────────────────────────────────────────────────────────────
    // STATUS BAR
    // ─────────────────────────────────────────────────────────────────────────

    private void UpdateStatusBar()
    {
        var rev = _selected?.Revision.ToString() ?? "—";
        lblFPS.Text = $"FPS: {Program.Fps}";
        lblRevision.Text = $"Revision: {rev}";
        lblPosition.Text = $"Position: {{{_mapMouse.X};{_mapMouse.Y}}}";
    }

    // ─────────────────────────────────────────────────────────────────────────
    // TOOLBAR HANDLERS
    // ─────────────────────────────────────────────────────────────────────────

    private void butSaveAll_Click(object? sender, RoutedEventArgs e)
    {
        foreach (var map in Map.List.Values) ++map.Revision;
        Send.WriteMaps();
        MessageBox.Show(@"All maps has been saved");
    }

    private void butReload_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null) return;
        Send.RequestMap(_selected);
        RefreshLayerList();
        _selected.Update();
    }

    // Drawing tools — mutual exclusion
    private void butPencil_Click(object? sender, RoutedEventArgs e)
    {
        if (butPencil.IsChecked == true) { butRectangle.IsChecked = false; butArea.IsChecked = false; butDiscover.IsChecked = false; }
        else butPencil.IsChecked = true;
        ResetMapSelectionSize();
    }

    private void butRectangle_Click(object? sender, RoutedEventArgs e)
    {
        if (butRectangle.IsChecked == true) { butPencil.IsChecked = false; butArea.IsChecked = false; butDiscover.IsChecked = false; }
        else butRectangle.IsChecked = true;
        ResetMapSelectionSize();
    }

    private void butArea_Click(object? sender, RoutedEventArgs e)
    {
        if (butArea.IsChecked == true) { butPencil.IsChecked = false; butRectangle.IsChecked = false; butDiscover.IsChecked = false; }
        else butArea.IsChecked = true;
        ResetMapSelectionSize();
    }

    private void butDiscover_Click(object? sender, RoutedEventArgs e)
    {
        if (butDiscover.IsChecked == true) { butPencil.IsChecked = false; butRectangle.IsChecked = false; butArea.IsChecked = false; }
        else butDiscover.IsChecked = true;
        ResetMapSelectionSize();
    }

    private void butFill_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null) return;
        var layer = SelectedLayerIndex();
        if (layer < 0) return;
        for (var x = 0; x < Map.Width; x++)
            for (var y = 0; y < Map.Height; y++)
                _selected.Layer[layer].Tile[x, y] = MakeSetTile();
        _selected.Update();
    }

    private void butEraser_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null) return;
        var layer = SelectedLayerIndex();
        if (layer < 0) return;
        for (var x = 0; x < Map.Width; x++)
            for (var y = 0; y < Map.Height; y++)
                _selected.Layer[layer].Tile[x, y] = new MapTileData();
    }

    private void butEdition_Click(object? sender, RoutedEventArgs e)
    {
        if (butEdition.IsChecked == true) butVisualization.IsChecked = false;
        else butEdition.IsChecked = true;
        Options.PreMapView = butVisualization.IsChecked == true;
        Client.Framework.Library.Write.Options();
    }

    private void butVisualization_Click(object? sender, RoutedEventArgs e)
    {
        if (butVisualization.IsChecked == true) butEdition.IsChecked = false;
        else butVisualization.IsChecked = true;
        Options.PreMapView = butVisualization.IsChecked == true;
        Client.Framework.Library.Write.Options();
    }

    private void butGrid_Click(object? sender, RoutedEventArgs e)
    {
        Options.PreMapGrid = butGrid.IsChecked == true;
        Client.Framework.Library.Write.Options();
    }

    private void butAudio_Click(object? sender, RoutedEventArgs e)
    {
        Options.PreMapAudio = butAudio.IsChecked == true;
        Client.Framework.Library.Write.Options();
        if (!Options.PreMapAudio) { Music.Stop(); Sound.StopAll(); }
    }

    // Zoom
    private void butZoom_Normal_Click(object? sender, RoutedEventArgs e)
    {
        if (butZoom_Normal.IsChecked == true) { butZoom_2x.IsChecked = false; butZoom_4x.IsChecked = false; }
        else butZoom_Normal.IsChecked = true;
        UpdateMapBounds();
    }

    private void butZoom_2x_Click(object? sender, RoutedEventArgs e)
    {
        if (butZoom_2x.IsChecked == true) { butZoom_Normal.IsChecked = false; butZoom_4x.IsChecked = false; }
        else butZoom_2x.IsChecked = true;
        UpdateMapBounds();
    }

    private void butZoom_4x_Click(object? sender, RoutedEventArgs e)
    {
        if (butZoom_4x.IsChecked == true) { butZoom_Normal.IsChecked = false; butZoom_2x.IsChecked = false; }
        else butZoom_4x.IsChecked = true;
        UpdateMapBounds();
    }

    // Mode toggle
    private void butMNormal_Click(object? sender, RoutedEventArgs e) { ModesExclusive(butMNormal); ResetMapSelectionSize(); }
    private void butMZones_Click(object? sender, RoutedEventArgs e) { ModesExclusive(butMZones); }
    private void butMAttributes_Click(object? sender, RoutedEventArgs e) { ModesExclusive(butMAttributes); }
    private void butMNPCs_Click(object? sender, RoutedEventArgs e)
    {
        ModesExclusive(butMNPCs);
        if (butMNPCs.IsChecked == true)
        {
            cmbNPC.Items.Clear();
            foreach (var npc in Npc.List.Values) cmbNPC.Items.Add(npc);
            if (cmbNPC.Items.Count > 0) cmbNPC.SelectedIndex = 0;
            numNPC_Zone.Value = 0;
        }
    }

    private void ModesExclusive(ToggleButton pressed)
    {
        foreach (var btn in new[] { butMNormal, butMZones, butMAttributes, butMNPCs })
            btn.IsChecked = btn == pressed ? (pressed.IsChecked != true || btn == butMNormal) : false;
        if (butMNormal.IsChecked != true)
        {
            butMNormal.IsChecked = false;
            butMZones.IsChecked = butMZones == pressed && pressed.IsChecked == true;
            butMAttributes.IsChecked = butMAttributes == pressed && pressed.IsChecked == true;
            butMNPCs.IsChecked = butMNPCs == pressed && pressed.IsChecked == true;
        }
        // Sync mode-panel visibility
        grpZones.IsVisible = butMZones.IsChecked == true;
        grpAttributes.IsVisible = butMAttributes.IsChecked == true;
        grpNPCs.IsVisible = butMNPCs.IsChecked == true;
    }

    // Other editor launchers
    private void butEditors_Classes_Click(object? sender, RoutedEventArgs e) => AvaloniaClassesLauncher.OpenClassesEditor(this);
    private void butEditors_Data_Click(object? sender, RoutedEventArgs e) => AvaloniaDataLauncher.OpenDataEditor(this);
    private void butEditors_Interface_Click(object? sender, RoutedEventArgs e) => AvaloniaInterfaceLauncher.OpenInterfaceEditor(this);
    private void butEditors_Items_Click(object? sender, RoutedEventArgs e) => AvaloniaItemsLauncher.OpenItemsEditor(this);
    private void butEditors_NPCs_Click(object? sender, RoutedEventArgs e) => AvaloniaNpcsLauncher.OpenNpcsEditor(this);
    private void butEditors_Shops_Click(object? sender, RoutedEventArgs e) => AvaloniaShopsLauncher.OpenShopsEditor(this);
    private void butEditors_Tiles_Click(object? sender, RoutedEventArgs e) => AvaloniaTilesLauncher.OpenTilesEditor(this);

    // Clipboard
    private void butCopy_Click(object? sender, RoutedEventArgs e) => CopyTiles();
    private void butCut_Click(object? sender, RoutedEventArgs e)
    {
        CopyTiles();
        var sel = MapSelection;
        for (var x = sel.X; x < sel.X + sel.Width; x++)
            for (var y = sel.Y; y < sel.Y + sel.Height; y++)
                for (byte c = 0; c < _selected!.Layer.Count; c++)
                    _selected.Layer[c].Tile[x, y] = new MapTileData();
        _selected!.Update();
    }
    private void butPaste_Click(object? sender, RoutedEventArgs e) => PasteTiles();

    // ─────────────────────────────────────────────────────────────────────────
    // MAP CANVAS POINTER EVENTS
    // ─────────────────────────────────────────────────────────────────────────

    private void imgMap_PointerPressed(object? sender, PointerPressedEventArgs e)
    {
        if (_selected == null) return;
        var pt = e.GetPosition(imgMap);
        var left = e.GetCurrentPoint(imgMap).Properties.IsLeftButtonPressed;
        var right = e.GetCurrentPoint(imgMap).Properties.IsRightButtonPressed;
        var btn = left ? MouseButtons.Left : (right ? MouseButtons.Right : MouseButtons.None);

        UpdateMapMouse(pt.X, pt.Y);
        var sel = MapSelection;
        if (sel.X >= Map.Width || sel.Y >= Map.Height) return;

        if (ModeNormal)
        {
            TileEvents(btn);
            if (ToolArea) _defMapSelection = new SystemRect(_mapMouse, new SystemSize(1, 1));
        }
        else if (ModeAttributes && DirBlockMode)
        {
            var tileDif = new SystemPoint((int)(pt.X - pt.X / Globals.Grid * Globals.Grid), (int)(pt.Y - pt.Y / Globals.Grid * Globals.Grid));
            for (byte i = 0; i < (byte)Direction.Count; i++)
                if (tileDif.X >= Block_Position(i).X && tileDif.X <= Block_Position(i).X + 8)
                    if (tileDif.Y >= Block_Position(i).Y && tileDif.Y <= Block_Position(i).Y + 8)
                        _selected.Attribute[sel.X, sel.Y].Block[i] = !_selected.Attribute[sel.X, sel.Y].Block[i];
        }
        else if (ModeAttributes && !DirBlockMode && left)
            SetAttribute();
        else if (ModeAttributes && right)
            _selected.Attribute[sel.X, sel.Y] = new MapAttribute();
        else if (ModeZones)
        {
            if (left) _selected.Attribute[sel.X, sel.Y].Zone = (byte)scrlZone.Value;
            if (right) _selected.Attribute[sel.X, sel.Y].Zone = 0;
        }
        else if (ModeNPCs && left)
            AddNpc(true, (byte)sel.X, (byte)sel.Y);
    }

    private void imgMap_PointerReleased(object? sender, PointerReleasedEventArgs e)
    {
        _mapPressed = false;
        var pt = e.GetPosition(imgMap);
        if (e.InitialPressMouseButton != MouseButton.Left) return;
        if (_selected == null) return;
        var layer = SelectedLayerIndex();
        if (layer < 0) return;
        var sel = MapSelection;
        if (sel.X >= Map.Width || sel.Y >= Map.Height) return;

        if (ToolRectangle && (sel.Width > 1 || sel.Height > 1))
        {
            for (var x = sel.X; x < sel.X + sel.Width; x++)
                for (var y = sel.Y; y < sel.Y + sel.Height; y++)
                {
                    _selected.Layer[layer].Tile[x, y] = MakeSetTile();
                    _selected.Layer[layer].Update(x, y);
                }
        }
        ResetMapSelectionSize();
    }

    private void imgMap_PointerMoved(object? sender, PointerEventArgs e)
    {
        if (_selected == null) return;
        var pt = e.GetPosition(imgMap);
        var left = e.GetCurrentPoint(imgMap).Properties.IsLeftButtonPressed;
        var right = e.GetCurrentPoint(imgMap).Properties.IsRightButtonPressed;
        var btn = left ? MouseButtons.Left : (right ? MouseButtons.Right : MouseButtons.None);

        UpdateMapMouse(pt.X, pt.Y);

        if (MapRectangle(pt.X, pt.Y, left)) return;
        if (ToolArea && IsToolEnabled(butArea)) return;

        _defMapSelection.Location = _mapMouse;

        if (ModeNormal)
            TileEvents(btn);
        else if (ModeZones)
        {
            if (left) _selected.Attribute[_mapMouse.X, _mapMouse.Y].Zone = (byte)scrlZone.Value;
            if (right) _selected.Attribute[MapSelection.X, MapSelection.Y].Zone = 0;
        }
        else if (ModeAttributes && !DirBlockMode)
        {
            if (left) _selected.Attribute[_mapMouse.X, _mapMouse.Y].Type = (byte)AttributeSelected();
            if (right) _selected.Attribute[MapSelection.X, MapSelection.Y].Type = 0;
        }
    }

    private void UpdateMapMouse(double px, double py)
    {
        var x = (int)(px / GridZoom) + (int)scrlMapX.Value;
        var y = (int)(py / GridZoom) + (int)scrlMapY.Value;
        _mapMouse = new SystemPoint(
            Math.Clamp(x, 0, Map.Width - 1),
            Math.Clamp(y, 0, Map.Height - 1));
    }

    // ─────────────────────────────────────────────────────────────────────────
    // TILE CANVAS POINTER EVENTS
    // ─────────────────────────────────────────────────────────────────────────

    private void imgTile_PointerPressed(object? sender, PointerPressedEventArgs e)
    {
        if (!e.GetCurrentPoint(imgTile).Properties.IsLeftButtonPressed) return;
        var pt = e.GetPosition(imgTile);
        var x = (int)(pt.X + scrlTileX.Value) / Globals.Grid;
        var y = (int)(pt.Y + scrlTileY.Value) / Globals.Grid;

        if (cmbTiles.SelectedIndex < 0) return;
        var tex = Textures.Tiles[cmbTiles.SelectedIndex + 1];
        if ((int)(pt.X + scrlTileX.Value) > tex.ToSize().Width) return;
        if ((int)(pt.Y + scrlTileY.Value) > tex.ToSize().Height) return;

        _defTilesSelection.Location = new SystemPoint(x, y);
        UpdateTileSelected();
    }

    private void imgTile_PointerMoved(object? sender, PointerEventArgs e)
    {
        if (cmbTiles.SelectedIndex < 0) return;
        var pt = e.GetPosition(imgTile);
        var x = (int)(pt.X + scrlTileX.Value) / Globals.Grid;
        var y = (int)(pt.Y + scrlTileY.Value) / Globals.Grid;
        var tex = Textures.Tiles[cmbTiles.SelectedIndex + 1];
        var size = tex.ToSize();

        TileMouse = new SystemPoint(x * Globals.Grid - (int)scrlTileX.Value, y * Globals.Grid - (int)scrlTileY.Value);

        if (!e.GetCurrentPoint(imgTile).Properties.IsLeftButtonPressed) return;
        if (AutoTile) return;

        x = Math.Clamp(x, 0, size.Width / Globals.Grid - 1);
        y = Math.Clamp(y, 0, size.Height / Globals.Grid - 1);

        _defTilesSelection.Width = x - _defTilesSelection.X + 1;
        _defTilesSelection.Height = y - _defTilesSelection.Y + 1;
    }

    // ─────────────────────────────────────────────────────────────────────────
    // SCROLLBARS
    // ─────────────────────────────────────────────────────────────────────────

    private void scrlMapX_Scroll(object? sender, AvaloniaScrollEventArgs e) { /* value binding auto */ }
    private void scrlMapY_Scroll(object? sender, AvaloniaScrollEventArgs e) { /* value binding auto */ }
    private void scrlTileX_Scroll(object? sender, AvaloniaScrollEventArgs e) { }
    private void scrlTileY_Scroll(object? sender, AvaloniaScrollEventArgs e) { }

    private void scrlZone_Scroll(object? sender, AvaloniaScrollEventArgs e)
    {
        var v = (int)scrlZone.Value;
        lblZone.Text = v == 0 ? "Zone: None" : "Zone: " + v;
    }

    private void scrlZone_Clear_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null) return;
        for (byte x = 0; x < Map.Width; x++)
            for (byte y = 0; y < Map.Height; y++)
                _selected.Attribute[x, y].Zone = 0;
    }

    // ─────────────────────────────────────────────────────────────────────────
    // TILE SHEET COMBO / AUTO
    // ─────────────────────────────────────────────────────────────────────────

    private void cmbTiles_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        scrlTileX.Value = 0;
        scrlTileY.Value = 0;
        chkAuto.IsChecked = false;
        UpdateTileBounds();
        TileMouse = new SystemPoint(0);
        _defTilesSelection = new SystemRect(0, 0, 1, 1);
        ResetMapSelectionSize();
    }

    private void chkAuto_IsCheckedChanged(object? sender, RoutedEventArgs e)
    {
        UpdateTileSelected();
    }

    private void UpdateTileSelected()
        => _defTilesSelection.Size = AutoTile ? new SystemSize(2, 3) : new SystemSize(1, 1);

    private void UpdateTileBounds()
    {
        if (cmbTiles.SelectedIndex < 0) return;
        var size = Textures.Tiles[cmbTiles.SelectedIndex + 1].ToSize();
        scrlTileX.Maximum = Math.Max(0, size.Width - TileCanvasWidth);
        scrlTileY.Maximum = Math.Max(0, size.Height - TileCanvasHeight);
    }

    // ─────────────────────────────────────────────────────────────────────────
    // LAYERS
    // ─────────────────────────────────────────────────────────────────────────

    private void RefreshLayerList()
    {
        if (_selected == null) return;
        _layerVms = _selected.Layer
            .Select((l, i) => new LayerVm
            {
                Index = i + 1,
                Name = l.Name,
                TypeName = ((Layer)l.Type).ToString(),
                Visible = true
            })
            .ToList();
        lstLayers.ItemsSource = null;
        lstLayers.ItemsSource = _layerVms;
        if (_layerVms.Count > 0) lstLayers.SelectedIndex = 0;
    }

    private void lstLayers_SelectionChanged(object? sender, SelectionChangedEventArgs e) { }

    private void layerVisible_Changed(object? sender, RoutedEventArgs e) { }

    public int SelectedLayerIndex()
    {
        if (lstLayers.SelectedItem is LayerVm vm) return vm.Index - 1;
        return -1;
    }

    private void butLayers_Add_Click(object? sender, RoutedEventArgs e)
    {
        _layerEditIsNew = true;
        txtLayer_Name.Text = string.Empty;
        cmbLayers_Type.SelectedIndex = 0;
        lblLayerEditTitle.Text = "Add layer";
        butLayer_Ok.Content = "Add";
        pnlLayerEdit.IsVisible = true;
    }

    private void butLayers_Edit_Click(object? sender, RoutedEventArgs e)
    {
        var idx = SelectedLayerIndex();
        if (idx < 0 || _selected == null) return;
        _layerEditIsNew = false;
        txtLayer_Name.Text = _selected.Layer[idx].Name;
        cmbLayers_Type.SelectedIndex = _selected.Layer[idx].Type;
        lblLayerEditTitle.Text = "Edit layer";
        butLayer_Ok.Content = "Save";
        pnlLayerEdit.IsVisible = true;
    }

    private void butLayer_Ok_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null) return;
        var name = txtLayer_Name.Text ?? string.Empty;
        if (name.Length < 1 || name.Length > 12) return;

        if (_layerEditIsNew)
        {
            if (FindLayer(name) >= 0) { MessageBox.Show(@"There is already a layer with that name."); return; }
            var layer = new MapLayer(name) { Type = (byte)cmbLayers_Type.SelectedIndex };
            for (byte x = 0; x < Map.Width; x++)
                for (byte y = 0; y < Map.Height; y++)
                    layer.Tile[x, y] = new MapTileData();
            _selected.Layer.Add(layer);
        }
        else
        {
            var idx = SelectedLayerIndex();
            if (idx < 0) return;
            if (_selected.Layer[idx].Name != name && FindLayer(name) >= 0)
            { MessageBox.Show(@"There is already a layer with this name."); return; }
            _selected.Layer[idx].Name = name;
            _selected.Layer[idx].Type = (byte)cmbLayers_Type.SelectedIndex;
        }

        SortLayers();
        pnlLayerEdit.IsVisible = false;
    }

    private void butLayer_Cancel_Click(object? sender, RoutedEventArgs e)
        => pnlLayerEdit.IsVisible = false;

    private void butLayers_Remove_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null || _selected.Layer.Count <= 1) return;
        var idx = SelectedLayerIndex();
        if (idx < 0) return;
        _selected.Layer.RemoveAt(idx);
        RefreshLayerList();
    }

    private void butLayers_Up_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null) return;
        var idx = SelectedLayerIndex();
        if (idx <= 0 || idx >= _selected.Layer.Count) return;
        if (_selected.Layer[idx - 1].Type != _selected.Layer[idx].Type) return;
        (_selected.Layer[idx], _selected.Layer[idx - 1]) = (_selected.Layer[idx - 1], _selected.Layer[idx]);
        RefreshLayerList();
        lstLayers.SelectedIndex = idx - 1;
    }

    private void butLayers_Down_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null) return;
        var idx = SelectedLayerIndex();
        if (idx < 0 || idx >= _selected.Layer.Count - 1) return;
        if (_selected.Layer[idx + 1].Type != _selected.Layer[idx].Type) return;
        (_selected.Layer[idx], _selected.Layer[idx + 1]) = (_selected.Layer[idx + 1], _selected.Layer[idx]);
        RefreshLayerList();
        lstLayers.SelectedIndex = idx + 1;
    }

    private void SortLayers()
    {
        var temp = new List<MapLayer>();
        for (byte n = 0; n < (byte)Layer.Count; n++)
            for (byte i = 0; i < _selected!.Layer.Count; i++)
                if (_selected.Layer[i].Type == n)
                    temp.Add(_selected.Layer[i]);
        _selected!.Layer = temp;
        RefreshLayerList();
    }

    private int FindLayer(string name)
    {
        for (byte i = 0; i < _selected!.Layer.Count; i++)
            if (_selected.Layer[i].Name == name) return i;
        return -1;
    }

    // ─────────────────────────────────────────────────────────────────────────
    // NPCs
    // ─────────────────────────────────────────────────────────────────────────

    private void RefreshNpcList()
    {
        if (_selected == null) return;
        lstNPC.ItemsSource = null;
        lstNPC.ItemsSource = _selected.Npc;
    }

    private void AddNpc(bool fixedSpawn = false, byte x = 0, byte y = 0)
    {
        if (_selected == null || cmbNPC.SelectedItem is not Npc npc) return;
        _selected.Npc.Add(new MapNpc
        {
            Npc = npc,
            Zone = (byte)(numNPC_Zone.Value ?? 0),
            Spawn = fixedSpawn,
            X = x,
            Y = y
        });
        RefreshNpcList();
    }

    private void butNPC_Add_Click(object? sender, RoutedEventArgs e) => AddNpc();
    private void butNPC_Remove_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null || lstNPC.SelectedIndex < 0) return;
        _selected.Npc.RemoveAt(lstNPC.SelectedIndex);
        RefreshNpcList();
    }
    private void butNPC_Clear_Click(object? sender, RoutedEventArgs e)
    {
        _selected?.Npc.Clear();
        RefreshNpcList();
    }

    // ─────────────────────────────────────────────────────────────────────────
    // ATTRIBUTES
    // ─────────────────────────────────────────────────────────────────────────

    private void optA_Warp_Changed(object? sender, RoutedEventArgs e)
    {
        grpA_Warp.IsVisible = optA_Warp.IsChecked == true;
        if (optA_Warp.IsChecked == true)
        {
            if (cmbA_Warp_Map.Items.Count > 0) cmbA_Warp_Map.SelectedIndex = 0;
            if (cmbA_Warp_Direction.Items.Count == 0)
                foreach (Direction d in Enum.GetValues<Direction>())
                    cmbA_Warp_Direction.Items.Add(d.ToString());
            cmbA_Warp_Direction.SelectedIndex = 0;
            numA_Warp_X.Value = 0;
            numA_Warp_Y.Value = 0;
        }
    }

    private void optA_Item_Changed(object? sender, RoutedEventArgs e)
    {
        if (optA_Item.IsChecked == true)
        {
            if (Item.List.Count == 0)
            {
                MessageBox.Show(@"It must have at least one item registered to use this attribute.");
                optA_Block.IsChecked = true;
                return;
            }
            cmbA_Item.Items.Clear();
            foreach (var item in Item.List.Values) cmbA_Item.Items.Add(item);
            if (cmbA_Item.Items.Count > 0) cmbA_Item.SelectedIndex = 0;
            numA_Item_Amount.Value = _aData2 = 1;
        }
        grpA_Item.IsVisible = optA_Item.IsChecked == true;
    }

    private void cmbA_Warp_Map_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        if (cmbA_Warp_Map.SelectedItem is Map m) _aData1 = m.GetId().ToString();
    }

    private void cmbA_Warp_Direction_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        _aData4 = (short)cmbA_Warp_Direction.SelectedIndex;
    }

    private void numA_Warp_X_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        _aData2 = (short)(e.NewValue ?? 0);
    }

    private void numA_Warp_Y_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        _aData3 = (short)(e.NewValue ?? 0);
    }

    private void cmbA_Item_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        if (cmbA_Item.SelectedItem is Item item) _aData1 = item.GetId().ToString();
    }

    private void numA_Item_Amount_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        _aData2 = (short)(e.NewValue ?? 0);
    }

    private void butAttributes_Clear_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null) return;
        for (byte x = 0; x < Map.Width; x++)
            for (byte y = 0; y < Map.Height; y++)
                _selected.Attribute[x, y] = new MapAttribute();
    }

    private void butAttributes_Import_Click(object? sender, RoutedEventArgs e)
    {
        if (_selected == null) return;
        for (byte x = 0; x < Map.Width; x++)
            for (byte y = 0; y < Map.Height; y++)
                for (byte c = 0; c < _selected.Layer.Count; c++)
                {
                    var data = _selected.Layer[c].Tile[x, y];
                    if (data.Texture <= 0) continue;
                    if (Tile.List[data.Texture].Data[data.X, data.Y].Attribute > 0)
                        _selected.Attribute[x, y].Type = Tile.List[data.Texture].Data[data.X, data.Y].Attribute;
                    for (byte b = 0; b < (byte)Direction.Count; b++)
                        if (Tile.List[data.Texture].Data[data.X, data.Y].Block[b])
                            _selected.Attribute[x, y].Block[b] = true;
                }
    }

    private TileAttribute AttributeSelected()
    {
        if (optA_Block.IsChecked == true) return TileAttribute.Block;
        if (optA_Warp.IsChecked == true) return TileAttribute.Warp;
        if (optA_Item.IsChecked == true) return TileAttribute.Item;
        return TileAttribute.None;
    }

    private void SetAttribute()
    {
        if (_selected == null) return;
        var sel = MapSelection;
        _selected.Attribute[sel.X, sel.Y].Data1 = _aData1;
        _selected.Attribute[sel.X, sel.Y].Data2 = _aData2;
        _selected.Attribute[sel.X, sel.Y].Data3 = _aData3;
        _selected.Attribute[sel.X, sel.Y].Data4 = _aData4;
        _selected.Attribute[sel.X, sel.Y].Type = (byte)AttributeSelected();
    }

    // ─────────────────────────────────────────────────────────────────────────
    // MAP PROPERTIES PANEL  (replaces WinForms PropertyGrid)
    // ─────────────────────────────────────────────────────────────────────────

    private void txtMapName_TextChanged(object? sender, TextChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        _selected.Name = txtMapName.Text ?? string.Empty;
        RefreshMapList(_selected.Id);
    }

    private void cmbMoral_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        _selected.Moral = (Moral)cmbMoral.SelectedIndex;
    }

    private void txtMapMusic_TextChanged(object? sender, TextChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        _selected.Music = txtMapMusic.Text ?? string.Empty;
    }

    private void numFogTexture_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        _selected.Fog.Texture = (byte)Math.Min(e.NewValue ?? 0, Textures.Fogs.Count - 1);
    }

    private void numFogAlpha_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        _selected.Fog.Alpha = (byte)(e.NewValue ?? 0);
    }

    private void numFogSpeedX_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        _selected.Fog.SpeedX = (sbyte)(e.NewValue ?? 0);
    }

    private void numFogSpeedY_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        _selected.Fog.SpeedY = (sbyte)(e.NewValue ?? 0);
    }

    private void cmbWeather_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        _selected.Weather.Type = (Weather)cmbWeather.SelectedIndex;
        TempMap.UpdateWeatherType();
    }

    private void numWeatherIntensity_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        _selected.Weather.Intensity = (byte)Math.Min(e.NewValue ?? 0, Globals.MaxWeatherIntensity);
    }

    private void numHueR_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        var c = _selected.Color;
        _selected.Color = SystemColor.FromArgb(c.A, (int)(e.NewValue ?? 255), c.G, c.B);
    }

    private void numHueG_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        var c = _selected.Color;
        _selected.Color = SystemColor.FromArgb(c.A, c.R, (int)(e.NewValue ?? 255), c.B);
    }

    private void numHueB_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        var c = _selected.Color;
        _selected.Color = SystemColor.FromArgb(c.A, c.R, c.G, (int)(e.NewValue ?? 255));
    }

    private void numLighting_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        _selected.Lighting = (byte)(e.NewValue ?? 100);
    }

    private void numPanorama_ValueChanged(object? sender, NumericUpDownValueChangedEventArgs e)
    {
        if (_loading || _selected == null) return;
        _selected.Panorama = (byte)Math.Min(e.NewValue ?? 0, Textures.Panoramas.Count - 1);
    }

    // ─────────────────────────────────────────────────────────────────────────
    // UTILS (mirrors WinForms Utils region)
    // ─────────────────────────────────────────────────────────────────────────

    private static SystemRect SelectionRec(SystemRect t)
    {
        if (t.Width <= 0) { t.X += t.Width - 1; t.Width = (t.Width - 2) * -1; }
        if (t.Height <= 0) { t.Y += t.Height - 1; t.Height = (t.Height - 2) * -1; }
        return t;
    }

    public SystemRect TilesSelection => SelectionRec(_defTilesSelection);

    public SystemRect MapSelection
    {
        get
        {
            if (AutoTile) return new SystemRect(_mapMouse, new SystemSize(1, 1));
            if (ModeNormal && ToolPencil) return new SystemRect(_mapMouse, TilesSelection.Size);
            return SelectionRec(_defMapSelection);
        }
    }

    public SystemRect TileSource => new(TilesSelection.X * Globals.Grid, TilesSelection.Y * Globals.Grid,
                                        TilesSelection.Width * Globals.Grid, TilesSelection.Height * Globals.Grid);

    public byte Zoom()
    {
        if (butZoom_2x.IsChecked == true) return 2;
        if (butZoom_4x.IsChecked == true) return 4;
        return 1;
    }

    public byte GridZoom => (byte)(Globals.Grid / Zoom());

    public SystemRect ZoomRect(SystemRect value)
        => new(value.X / Zoom(), value.Y / Zoom(), value.Width / Zoom(), value.Height / Zoom());

    public SystemPoint ZoomGrid(int x, int y)
        => new(x * GridZoom, y * GridZoom);

    // Layer visibility check (replaces lstLayers.Items[c].Checked)
    public bool IsLayerVisible(int index)
        => index < _layerVms.Count && _layerVms[index].Visible;

    private void UpdateMapBounds()
    {
        if (_selected == null) return;
        scrlMapX.Maximum = Math.Max(0, (Map.Width / Zoom() * Globals.Grid - MapCanvasWidth) / Globals.Grid);
        scrlMapY.Maximum = Math.Max(0, (Map.Height / Zoom() * Globals.Grid - MapCanvasHeight) / Globals.Grid);
        scrlMapX.Value = 0;
        scrlMapY.Value = 0;
    }

    private void ResetMapSelectionSize() => _defMapSelection.Size = new SystemSize(1, 1);

    private static bool IsToolEnabled(ToggleButton btn) => btn.IsEnabled && btn.IsChecked == true;

    private void TileEvents(MouseButtons btn)
    {
        if (_selected == null) return;
        var layer = SelectedLayerIndex();
        if (layer < 0) return;

        if (btn == MouseButtons.Left)
        {
            if (ToolPencil) TileSet((byte)layer);
            if (ToolDiscover) TileDiscover();
        }
        else if (btn == MouseButtons.Right)
        {
            if (ToolPencil) TileClear((byte)layer);
        }
    }

    private bool MapRectangle(double px, double py, bool left)
    {
        var x = (int)(px / GridZoom) + (int)scrlMapX.Value;
        var y = (int)(py / GridZoom) + (int)scrlMapY.Value;

        if (!left) return false;
        if (!IsToolEnabled(butRectangle) && !IsToolEnabled(butArea)) return false;

        if (!_mapPressed) _defMapSelection.Size = new SystemSize(1, 1);
        x = Math.Clamp(x, 0, Map.Width - 1);
        y = Math.Clamp(y, 0, Map.Height - 1);
        _defMapSelection.Width = x - _defMapSelection.X + 1;
        _defMapSelection.Height = y - _defMapSelection.Y + 1;
        _mapPressed = true;
        return true;
    }

    private void TileDiscover()
    {
        if (_selected == null) return;
        for (var c = _selected.Layer.Count - 1; c >= 0; c--)
        {
            var data = _selected.Layer[c].Tile[MapSelection.X, MapSelection.Y];
            if (!IsLayerVisible(c)) continue;
            if (data.Texture == 0) continue;
            cmbTiles.SelectedIndex = data.Texture - 1;
            chkAuto.IsChecked = data.IsAutoTile;
            _defTilesSelection = new SystemRect(data.X, data.Y, 1, 1);
            return;
        }
    }

    private MapTileData MakeSetTile(byte x = 0, byte y = 0)
    {
        if (x == 0) x = (byte)TilesSelection.X;
        if (y == 0) y = (byte)TilesSelection.Y;
        return new MapTileData
        {
            Mini = new SystemPoint[4],
            X = x,
            Y = y,
            Texture = (byte)(cmbTiles.SelectedIndex + 1),
            IsAutoTile = AutoTile
        };
    }

    private void TileSet(byte layerNum)
    {
        if (_selected == null) return;
        if (TilesSelection.Width > 1 || TilesSelection.Height > 1)
            TileSetMultiples(layerNum);
        _selected.Layer[layerNum].Tile[MapSelection.X, MapSelection.Y] = MakeSetTile();
        _selected.Layer[layerNum].Update(MapSelection.X, MapSelection.Y);
    }

    private void TileSetMultiples(byte layerNum)
    {
        if (_selected == null || AutoTile) return;
        byte x2 = 0;
        for (var x = MapSelection.X; x < MapSelection.X + TilesSelection.Width; x++)
        {
            byte y2 = 0;
            for (var y = MapSelection.Y; y < MapSelection.Y + TilesSelection.Height; y++)
            {
                if (!Map.OutLimit((short)x, (short)y))
                {
                    _selected.Layer[layerNum].Tile[x, y] = MakeSetTile((byte)(TilesSelection.X + x2), (byte)(TilesSelection.Y + y2));
                    _selected.Layer[layerNum].Update(x, y);
                }
                y2++;
            }
            x2++;
        }
    }

    private void TileClear(byte layerNum)
    {
        if (_selected == null) return;
        _selected.Layer[layerNum].Tile[MapSelection.X, MapSelection.Y] = new MapTileData { Mini = new SystemPoint[4] };
        _selected.Layer[layerNum].Update(MapSelection.X, MapSelection.Y);
    }

    // Clipboard
    private void CopyTiles()
    {
        if (_selected == null) return;
        _tilesCopy.Data = new MapLayer[_selected.Layer.Count];
        _tilesCopy.Area = MapSelection;
        for (byte c = 0; c < _tilesCopy.Data.Length; c++)
        {
            _tilesCopy.Data[c] = new MapLayer(_selected.Layer[c].Name);
            for (byte x = 0; x < Map.Width; x++)
                for (byte y = 0; y < Map.Height; y++)
                    _tilesCopy.Data[c].Tile[x, y] = _selected.Layer[c].Tile[x, y];
        }
        butPaste.IsEnabled = true;
    }

    private void PasteTiles()
    {
        if (_selected == null || _tilesCopy.Data == null) return;
        for (var x = _tilesCopy.Area.X; x < _tilesCopy.Area.X + _tilesCopy.Area.Width; x++)
            for (var y = _tilesCopy.Area.Y; y < _tilesCopy.Area.Y + _tilesCopy.Area.Height; y++)
                for (byte c = 0; c < _tilesCopy.Data.Length; c++)
                {
                    var layer = FindLayer(_tilesCopy.Data[c].Name);
                    var x2 = MapSelection.X + x - _tilesCopy.Area.X;
                    var y2 = y + MapSelection.Y - _tilesCopy.Area.Y;
                    if (layer < 0 || x2 >= Map.Width || y2 >= Map.Height) continue;
                    _selected.Layer[layer].Tile[x2, y2] = _tilesCopy.Data[c].Tile[x, y];
                }
        _selected.Update();
    }
}
